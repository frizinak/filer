<?php
define('FILER_CRON', 'filer:cron');

/**
 * Implements hook_cron_queue_info().
 */
function filer_cron_queue_info() {
  $queues[FILER_CRON] = array(
    'worker callback' => 'filer_cron_callback',
    'time' => 30,
  );

  return $queues;
}

/**
 * Main cron callback.
 * This function will open the file and write the return value of the given callback function, if the return value is a string.
 * Passes the provided data, file contents, the filehandle and a status indicator to the callback.
 * Status indicator will be 'first', empty or 'last'.
 */
function filer_cron_callback($data) {
  $filer = new Filer($data['id']);
  $filer_row = $filer->getFiles($data['frid']);
  if (!isset($filer_row['callback'])) {
    $filer->deleteRow($data['frid']);
    watchdog('filer', 'Invalid data in filer table', $filer_row);
    return;

  }
  $callback = $filer_row['callback'];
  $fn = $data['filepath'];
  $tmp_fn = $data['filepath'] . '.tmp';
  if (!function_exists($callback)) {
    watchdog('filer', 'callback function %func was not found', array('%func' => $callback));
    return;
  }
  if (!$fh = fopen($tmp_fn, $data['fmode'])) {
    watchdog('filer', 'could not open file: %file', array('%file' => $tmp_fn));
    return;
  }
  $content = '';
  if (!empty($data['read'])) {
    clearstatcache(TRUE);
    $content = fread($fh, filesize($tmp_fn));
  }
  $return = call_user_func($callback, $data['data'], $content, $fh, $data['status']);
  if (is_string($return) && fwrite($fh, $return) === FALSE) {
    watchdog('filer', 'could not write to %file', array('%file' => $tmp_fn));
  }
  fclose($fh);
  if ($data['status'] === 'last') {
    if (!rename($tmp_fn, $fn)) {
      watchdog('filer', 'could not rename %file to %nfile', array('%file' => $tmp_fn, '%nfile' => $fn));
    }
    $filer->finish($data['frid']);
  }
}
